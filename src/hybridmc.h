#ifndef __HYBRIDMC_H_
#define __HYBRIDMC_H_


#include <iostream>
#include <math.h>
#include <limits>
#include <omp.h>

#include <gsl/gsl_randist.h>
#include <gsl/gsl_rng.h>

#include "stats.h"


void seed_gsl_rng(gsl_rng **r);	// Seed a gsl_rng with the Unix time in nanoseconds


template<class TParams, class TLogger>
class THybridMC {
	double *q, *p;		// Position and momentum
	size_t dim;		// Dimensionality of parameter space
	TParams &params;	// Additional parameters passed to pdf
	TLogger &logger;	// Object which gets passed elements in chain
	TStats &stats;		// Logs means and covariance
	
	unsigned int weight;			// # of steps system has spent at current position q
	double U_0;				// Potential energy of current state
	double *q_workspace, *p_workspace;	// Proposal q and p generated by integrating forward
	gsl_rng *r;				// Random number generator
	
	uint64_t N_accepted, N_rejected;
	
public:
	// Typedefs for log(pdf) and random state functions
	typedef double (*log_pdf_t)(const double *const q, size_t dim, TParams &params);
	typedef double (*rand_state_t)(double *q, size_t dim, gsl_rng *r, TParams &params);
	
	// Constructor & Destructor
	THybridMC(size_t _dim, log_pdf_t _log_pdf, rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats);
	~THybridMC();
	
	// Mutators
	void step(unsigned int L, double eta, bool log_step=true);					// Take one hybrid Monte Carlo step
	void tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds=20);	// Tune L and eta to achieve the desired acceptance rate
	void flush();											// Log the current state
	
	// Testing functions
	void test_integration(double *q_0, double *p_0, unsigned int L, double eta);
	
	// Accessors
	double acceptance_rate();
	void clear_acceptance_rate();
	
private:
	log_pdf_t log_pdf;		// log(p(q)) = -U(q) , where U(q) is the potential energy of the system at q
	rand_state_t rand_state;	// Generate a random position vector q
	
	void draw_p();							// Draw momentum from unit Gaussian
	void leapfrog(unsigned int L, double eta);			// Leapfrog integrate forward L steps with stepsize eta
	
	double delE_delqi(double eta, size_t i, bool use_workspace);	// Calculate dE/dq_i around q', p'
	double delE_delqi(double eta, size_t i);			// Calculate dE/dq_i around q, p
	
	double T();							// Calculate kinetic energy T(p)
	double T_prime();						// Calculate kinetic energy T(p')
	double H();							// Calculate H(q, p)
	double H_prime();						// Calculate H(q', p')
};

// Encapsulates several Hybrid Monte Carlo objects, which step simultaneously
template<class TParams, class TLogger>
class TParallelHybridMC {
	THybridMC<TParams, TLogger> **hmc;
	TStats **component_stats;
	unsigned int N_hmc;
	
	TParams &params;	// Additional parameters passed to pdf
	TLogger &logger;	// Object which gets passed elements in chain
	TStats &stats;		// Logs means and covariance
	
	size_t dim;		// Dimensionality of parameter space
	double *GR_stat;
	
public:
	// Constructor & Destructor
	TParallelHybridMC(unsigned int _N_hmc, size_t _dim, typename THybridMC<TParams, TLogger>::log_pdf_t _log_pdf, typename THybridMC<TParams, TLogger>::rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats);
	~TParallelHybridMC();
	
	// Mutators
	void step(unsigned int L, double eta, bool log_step=true);					// Take one hybrid Monte Carlo step in each HMC sampler
	void tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds=20);	// Tune L and eta to achieve the desired acceptance rate
	void flush();											// Log the current state in each sampler
	void clear_acceptance_rate();									// Clear the N_accepted and N_rejected counters
	
	void step_multiple(unsigned int N_steps, unsigned int L, double eta, bool log_step=true);	// Take several steps in each sampler
	void calc_GR_stat();										// Calculate the Gelman-Rubin diagnostic along each axis
	void update_stats();										// Update the stats object from the stats of each sampler
	
	// Accessors
	double acceptance_rate() const;		// Return the rate of acceptance of proposal points
	double get_GR_stat(size_t i)const;	// Get Gelman-Rubin statistic for axis i
	
private:
	typename THybridMC<TParams, TLogger>::log_pdf_t log_pdf;	// Target distribution: log(p(q)) = -U(q) , where U(q) is the potential energy of the system at q
	typename THybridMC<TParams, TLogger>::rand_state_t rand_state;	// Generate a random position vector q
};


/** ********************************************************************************************************************************************************************************
 * 
 *  TParallelHybridMC member functions
 * 
 **********************************************************************************************************************************************************************************/

template<class TParams, class TLogger>
TParallelHybridMC<TParams, TLogger>::TParallelHybridMC(unsigned int _N_hmc, size_t _dim, typename THybridMC<TParams, TLogger>::log_pdf_t _log_pdf, typename THybridMC<TParams, TLogger>::rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats)
	: hmc(NULL), component_stats(NULL), GR_stat(NULL), log_pdf(_log_pdf), rand_state(_rand_state), params(_params), logger(_logger), stats(_stats), N_hmc(_N_hmc), dim(_dim)
{
	component_stats = new TStats*[N_hmc];
	hmc = new THybridMC<TParams, TLogger>*[N_hmc];
	for(unsigned int i=0; i<N_hmc; i++) {
		component_stats[i] = new TStats(dim);
		hmc[i] = new THybridMC<TParams, TLogger>(dim, log_pdf, rand_state, params, logger, *component_stats[i]);
	}
	GR_stat = new double[dim];
	for(unsigned int i=0; i<dim; i++) { GR_stat[i] = std::numeric_limits<double>::infinity(); }
}

template<class TParams, class TLogger>
TParallelHybridMC<TParams, TLogger>::~TParallelHybridMC() {
	for(unsigned int i=0; i<N_hmc; i++) {
		delete hmc[i];
		delete component_stats[i];
	}
	delete[] hmc;
	delete[] component_stats;
	delete[] GR_stat;
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::step(unsigned int L, double eta, bool log_step) {
	#pragma omp parallel for
	for(unsigned int i=0; i<N_hmc; i++) { hmc[i]->step(L, eta, log_step); }
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds) {
	double new_eta = 0.;
	unsigned int new_L = 0;
	
	#pragma omp parallel num_threads(N_hmc)
	{
		unsigned int L_i = L;
		double eta_i = eta;
		unsigned int thread_ID = omp_get_thread_num();
		
		hmc[thread_ID]->tune(L_i, eta_i, target_acceptance, N_rounds);
		
		//#pragma omp critical (cout)
		//std::cout << "eta[" << thread_ID << "] = " << eta_i << std::endl;
		
		#pragma omp atomic
		new_L += L_i;
		
		#pragma omp atomic
		new_eta += eta_i;
	}
	
	L = new_L / N_hmc;
	eta = new_eta/(double)N_hmc;
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::flush() {
	#pragma omp parallel for
	for(unsigned int i=0; i<N_hmc; i++) { hmc[i]->flush(); }
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::clear_acceptance_rate() {
	for(unsigned int i=0; i<N_hmc; i++) { hmc[i]->clear_acceptance_rate(); }
}

template<class TParams, class TLogger>
double TParallelHybridMC<TParams, TLogger>::acceptance_rate() const {
	double accept = 0.;
	for(unsigned int i=0; i<N_hmc; i++) { accept += hmc[i]->acceptance_rate(); }
	return accept / (double)N_hmc;
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::step_multiple(unsigned int N_steps, unsigned int L, double eta, bool log_step) {
	#pragma omp parallel for
	for(unsigned int i=0; i<N_hmc; i++) {
		for(unsigned int n=0; n<N_steps; n++) { hmc[i]->step(L, eta, log_step); }
	}
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::calc_GR_stat() {
	update_stats();
	Gelman_Rubin_diagnostic(component_stats, N_hmc, GR_stat, dim);
}

template<class TParams, class TLogger>
void TParallelHybridMC<TParams, TLogger>::update_stats() {
	flush();
	stats.clear();
	for(unsigned int i=0; i<N_hmc; i++) {
		stats += *component_stats[i];
	}
}

template<class TParams, class TLogger>
double TParallelHybridMC<TParams, TLogger>::get_GR_stat(size_t i) const {
	assert(i < dim);
	return GR_stat[i];
}


/** ********************************************************************************************************************************************************************************
 * 
 *  THybridMC member functions
 * 
 **********************************************************************************************************************************************************************************/

template<class TParams, class TLogger>
THybridMC<TParams, TLogger>::THybridMC(size_t _dim, log_pdf_t _log_pdf, rand_state_t _rand_state, TParams &_params, TLogger &_logger, TStats &_stats)
	: dim(_dim), log_pdf(_log_pdf), rand_state(_rand_state), params(_params), logger(_logger), stats(_stats), q(NULL), p(NULL), q_workspace(NULL), p_workspace(NULL), r(NULL)
{
	seed_gsl_rng(&r);
	
	q = new double[dim];
	p = new double[dim];
	q_workspace = new double[dim];
	p_workspace = new double[dim];
	
	rand_state(q, dim, r, params);
	U_0 = -log_pdf(q, dim, params);
	weight = 1;
	
	N_accepted = 0;
	N_rejected = 0;
}

template<class TParams, class TLogger>
THybridMC<TParams, TLogger>::~THybridMC() {
	delete[] q;
	delete[] p;
	delete[] q_workspace;
	delete[] p_workspace;
	gsl_rng_free(r);
}

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::step(unsigned int L, double eta, bool log_step) {
	// Draw a new momentum from a Gaussian distribution
	draw_p();
	// Calculate initial kinetic energy (initial potential energy is already known)
	//double Delta_H = -H();
	double T_0 = T();
	// Leapfrog integrate forward in time to generate (q', p')
	double eta_prime = eta * (1. + 0.8*(gsl_rng_uniform(r)-0.5));
	leapfrog(L, eta_prime);
	//if(gsl_rng_uniform(r) < 0.5) { leapfrog(L, eta_prime); } else { leapfrog(L, -eta_prime); }
	// Calculate final energy
	double T_1 = T_prime();
	double U_1 = -log_pdf(q_workspace, dim, params);
	// Calculate increase in energy = H' - H
	double Delta_H = (U_1 + T_1) - (U_0 + T_0);
	//Delta_H += H_prime();
	// Accept with probability min(1, exp(H - H'))
	bool accept = false;
	if(Delta_H < 0) {
		//std::cout << Delta_H << std::endl;
		accept = true;
	} else {
		double urand = gsl_rng_uniform(r);
		double prob = exp(-Delta_H);
		if(urand < prob) {
			accept = true;
		}
	}
	if(accept) {
		if(log_step) {
			#pragma omp critical (logger)
			logger(q, weight);
			
			#pragma omp critical (stats)
			stats(q, weight);
			
			weight = 1;
		}
		// Set q -> q', p -> p'
		double *q_tmp = q;
		double *p_tmp = p;
		q = q_workspace;	// Do the copying by just switching pointers
		p = p_workspace;
		q_workspace = q_tmp;	// q' and p' will be initialized to q and p, respectively, when the next Leapfrog integration begins
		p_workspace = p_tmp;
		U_0 = U_1;		// Store the potential energy at this point, so that it does not need to be re-evaluated later
		N_accepted++;
	} else {
		if(log_step) { weight++; }
		N_rejected++;
	}
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::T() {
	double T_tmp = 0;
	for(size_t i=0; i<dim; i++) { T_tmp += p[i]*p[i]; }
	return T_tmp/2.;
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::T_prime() {
	double T_tmp = 0;
	for(size_t i=0; i<dim; i++) { T_tmp += p_workspace[i]*p_workspace[i]; }
	return T_tmp/2.;
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::H() {
	double H_tmp = T();
	H_tmp -= log_pdf(q, dim, params);
	return H_tmp;
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::H_prime() {
	double H_tmp = T_prime();
	H_tmp -= log_pdf(q_workspace, dim, params);
	return H_tmp;
}

template<class TParams, class TLogger>
inline void THybridMC<TParams, TLogger>::draw_p() {
	for(size_t i=0; i<dim; i++) { p[i] = gsl_ran_gaussian_ziggurat(r, 1.); }
}

template<class TParams, class TLogger>
inline void THybridMC<TParams, TLogger>::leapfrog(unsigned int L, double eta) {
	// Half-step in p
	for(size_t i=0; i<dim; i++) { p_workspace[i] = p[i] - 0.5*eta*delE_delqi(eta, i); }
	// Full step in q
	for(size_t i=0; i<dim; i++) { q_workspace[i] = q[i] + eta*p[i]; }
	for(unsigned int n=0; n<L-1; n++) {
		// Full step in p
		for(size_t i=0; i<dim; i++) { p_workspace[i] -= eta*delE_delqi(eta, i, true); }
		// Full step in q
		for(size_t i=0; i<dim; i++) { q_workspace[i] += eta*p_workspace[i]; }
	}
	// Half-step in p
	for(size_t i=0; i<dim; i++) { p_workspace[i] -= 0.5*eta*delE_delqi(eta, i, true); }
}

// TODO: Deal with boundaries where E -> +infinity
// Estimate delE/delq_i by sampling E at q_i +- Delta_q
template<class TParams, class TLogger>
inline double THybridMC<TParams, TLogger>::delE_delqi(double eta, size_t i, bool use_workspace) {
	// Determine size of step to determine derivative
	double delta_q = eta*p_workspace[i]/100.;
	if(delta_q == 0) { delta_q = eta*0.001; }
	// Get E(q+delta_q)
	double q_i_tmp = q_workspace[i];
	q_workspace[i] += delta_q;
	double Delta_E = -log_pdf(q_workspace, dim, params);
	// Get E(q-delta_q)
	q_workspace[i] = q_i_tmp - delta_q;
	Delta_E -= -log_pdf(q_workspace, dim, params);
	q_workspace[i] = q_i_tmp;
	// Use finite difference to estimate derivative
	return Delta_E/(2.*delta_q);
}

// Overloaded version of above, using q rather than q_workspace
template<class TParams, class TLogger>
inline double THybridMC<TParams, TLogger>::delE_delqi(double eta, size_t i) {
	// Determine size of step to determine derivative
	double delta_q = eta*p[i]/100.;
	if(delta_q == 0) { delta_q = eta*0.01; }
	// Get E(q+delta_q)
	double q_i_tmp = q[i];
	q[i] += delta_q;
	double Delta_E = -log_pdf(q, dim, params);
	// Get E(q-delta_q)
	q[i] = q_i_tmp - delta_q;
	Delta_E += log_pdf(q, dim, params);
	q[i] = q_i_tmp;
	// Use finite difference to estimate derivative
	return Delta_E/(2.*delta_q);
}

template<class TParams, class TLogger>
double THybridMC<TParams, TLogger>::acceptance_rate() { return (double)N_accepted / (double)(N_accepted + N_rejected); }

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::clear_acceptance_rate() { N_accepted = 0; N_rejected = 0; }

// Adjust the step size eta to achieve the desired acceptance rate
template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::tune(unsigned int &L, double &eta, double target_acceptance, unsigned int N_rounds) {
	unsigned int N_steps = (unsigned int)(50./target_acceptance);	// Step enough times to get ~50 acceptances if eta and L are already correct
	double eta_new, lnc, lnp_0;
	double lnp = log(target_acceptance);
	double n = 3.;
	
	for(unsigned int k=0; k<N_rounds; k++) {
		clear_acceptance_rate();
		for(unsigned int i=0; i<N_steps; i++) { step(L, eta, false); }
		if(N_accepted == 0) {
			eta /= 1.2;
		} else if(N_rejected == 0) {
			eta *= 1.1;
		} else {
			double acceptance = acceptance_rate();
			if(acceptance < 0.9*target_acceptance) {
				eta *= 0.97;
			} else if(acceptance > 1.1*target_acceptance) {
				eta *= 1.03;
			}
		}
	}
}

template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::flush() {
	#pragma omp critical (logger)
	logger(q, weight);
	
	#pragma omp critical (stats)
	stats(q, weight);
	
	weight = 0;
}



template<class TParams, class TLogger>
void THybridMC<TParams, TLogger>::test_integration(double *q_0, double *p_0, unsigned int L, double eta) {
	// Copy in state (q_0, p_0)
	for(size_t i=0; i<dim; i++) {
		q[i] = q_0[i];
		p[i] = p_0[i];
	}
	// Integrate forward L steps
	double t = 0;
	for(unsigned int n=0; n<L; n++) {
		leapfrog(1, eta);
		// Print out t, q, p
		t += eta;
		std::cout << "t = " << t << "\tH = " << H_prime() << std::endl;
		std::cout << "q = (";
		for(size_t i=0; i<dim; i++) {
			std::cout << " " << q_workspace[i];
		}
		std::cout << " )" << std::endl;
		std::cout << "p = (";
		for(size_t i=0; i<dim; i++) {
			std::cout << " " << p_workspace[i];
		}
		std::cout << " )" << std::endl << std::endl;
		// Copy (q', p') to (q, p)
		for(size_t i=0; i<dim; i++) {
			q[i] = q_workspace[i];
			p[i] = p_workspace[i];
		}
	}
	// Copy state out to (q_0, p_0)
	for(size_t i=0; i<dim; i++) {
		q_0[i] = q[i];
		p_0[i] = p[i];
	}	
}



// Seed a gsl_rng with the Unix time in nanoseconds
inline void seed_gsl_rng(gsl_rng **r) {
	timespec t_seed;
	clock_gettime(CLOCK_REALTIME, &t_seed);
	long unsigned int seed = 1e9*(long unsigned int)t_seed.tv_sec;
	seed += t_seed.tv_nsec;
	*r = gsl_rng_alloc(gsl_rng_taus);
	gsl_rng_set(*r, seed);
}

#endif // __HYBRIDMC_H_